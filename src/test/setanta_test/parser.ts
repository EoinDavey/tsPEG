/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* ---
* import { Context } from "setanta/node_build/ctx";
* import { PossibleResolution, callFunc, idxList, Value } from "setanta/node_build/values";
* import { unescapeChars } from "setanta/node_build/teacs";
* import * as Asserts from "setanta/node_build/asserts";
* import * as Checks from "setanta/node_build/checks";
* import { orBinOp, orQuickBinOp, andBinOp, andQuickBinOp,
*     binOpEvalFn, binOpQuickEvalFn } from "setanta/node_build/binops";
* import { objLookupsEval, postfixArgsEval, csArgsEval, prefEval, EvalFn } from "setanta/node_build/evals";
* import { qEvalToEval } from "setanta/node_build/evals";
* import * as Quick from "setanta/node_build/quickevals";
* import { ASTVisitor } from "setanta/node_build/visitor";
* type Acceptor = <T>(visitor: ASTVisitor<T>) => T;
* ---
* Program     := stmts=AsgnStmt* _
* AsgnStmt    := IfStmt
*              | BlockStmt
*              | NuairStmt
*              | LeStmt
*              | CCStmt
*              | BrisStmt
*              | CtlchStmt
*              | GniomhStmt
*              | ToradhStmt
*              | AssgnStmt
*              | DefnStmt
*              | Expr
* NonAsgnStmt := IfStmt
*              | NuairStmt
*              | LeStmt
*              | CCStmt
*              | BrisStmt
*              | ToradhStmt
*              | BlockStmt
*              | AssgnStmt
*              | Expr
* IfStmt      := _ 'm[áa]' &gap expr=Expr &gap stmt=NonAsgnStmt elsebranch={_ 'n[oó]' &gap stmt=NonAsgnStmt}?
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitIfStmt(this); }
* BlockStmt   := _ '{' blk=AsgnStmt* _ '}'
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitBlockStmt(this); }
* NuairStmt   := _ 'nuair-a' expr=Expr &gap stmt=NonAsgnStmt
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitNuairStmt(this); }
* LeStmt      := _ 'le' &gap id=ID _ 'idir' _ '\('strt=Expr _ ',' end=Expr step={_ ',' step=Expr}? _ '\)' stmt=NonAsgnStmt
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitLeStmt(this); }
* DefnStmt    := _ idstart=@ id=ID idend=@ _ ':=' _ expr=Expr
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitDefnStmt(this); }
* AssgnStmt   := _ lstart=@ lhs=Postfix lend=@ _ op=AsgnOp _ expr=Expr
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitAssgnStmt(this); }
* GniomhStmt  := _ 'gn[íi]omh' &gap id=ID _ '\(' args=CSIDs? _ '\)' _ '{'
*     stmts=AsgnStmt*
* _ '}'
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitGniomhStmt(this); }
* CtlchStmt   := _ 'creatlach' &gap id=ID tuis={_ 'ó' &gap parentstart=@ id=ID parentend=@}? _ '{'
*     gniomhs=GniomhStmt*
* _ '}'
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitCtlchStmt(this); }
* BrisStmt    := _ 'bris'
* CCStmt      := _ 'chun-cinn'
* ToradhStmt  := _ 'toradh' &gap exp=Expr?
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitToradhStmt(this); }
* Expr        := And
* And         := start=@ head=Or tail={_ '\&' trm=Or}* end=@
*                .evalfn = EvalFn { return andBinOp(this); }
*                .qeval = Quick.MaybeEv { return andQuickBinOp(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitAnd(this); }
* Or          := start=@ head=Eq tail={_ '\|' trm=Eq}* end=@
*                .evalfn = EvalFn { return orBinOp(this) }
*                .qeval = Quick.MaybeEv { return orQuickBinOp(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitOr(this); }
* Eq          := start=@ head=Comp tail={_ op='[!=]=' trm=Comp}* end=@
*                .evalfn = EvalFn { return binOpEvalFn(this) }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitEq(this); }
* Comp        := start=@ head=Sum tail={_ op=Compare trm=Sum}* end=@
*                .evalfn = EvalFn { return binOpEvalFn(this) }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitComp(this); }
* Sum         := start=@ head=Product tail={_ op=PlusMinus trm=Product}* end=@
*                .evalfn = EvalFn { return binOpEvalFn(this) }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitSum(this); }
* Product     := start=@ head=Prefix tail={_ op=MulDiv trm=Prefix}* end=@
*                .evalfn = EvalFn { return binOpEvalFn(this); }
*                .qeval = Quick.MaybeEv { return binOpQuickEvalFn(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitProduct(this); }
* Prefix      := _ start=@ op='-|!'? pf=Postfix end=@
*                .evalfn = EvalFn { return prefEval(this); }
*                .qeval = Quick.MaybeEv { return Quick.qPrefEval(this); }
* Postfix     := start=@ at=ObjLookups ops=PostOp* end=@
*                .evalfn = EvalFn { return postfixArgsEval(this); }
*                .qeval = Quick.MaybeEv { return Quick.qPostfixArgsEval(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitPostfix(this); }
* ObjLookups  := start=@ attrs={id=ID '@' !wspace}* root=Atom end=@
*                .evalfn = EvalFn { return objLookupsEval(this); }
*                .qeval = Quick.MaybeEv { return Quick.qObjLookupsEval(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitObjLookups(this); }
* PostOp      := '\(' args=CSArgs? _ '\)' | '\[' expr=Expr _ '\]'
* Atom        :=  _ '\(' trm=Expr _ '\)'
*                .evalfn = EvalFn { return (env: Context) => this.trm.evalfn(env); }
*                .qeval = Quick.MaybeEv {
*                     const childF = this.trm.qeval;
*                     return childF === null ? null : childF.bind(this.trm);
*                }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitExpr(this.trm); }
*              | ID
*              | Teacs
*              | Int
*              | Bool
*              | Neamhni
*              | ListLit
*              | GniomhExpr
* GniomhExpr  := _ 'gn[íi]omh' _ '\(' args=CSIDs? _ '\)' _ '{'
*     stmts=AsgnStmt*
* _ '}'
*                .evalfn = EvalFn { return qEvalToEval(Quick.qGníomhEval(this)); }
*                .qeval = Quick.EvalFn { return Quick.qGníomhEval(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitGniomhExpr(this); }
* ListLit     := _ '\[' els=CSArgs? _ '\]'
*                .evalfn = EvalFn {
*                    return (env: Context) => this.els ? this.els.evalfn(env) : Promise.resolve([]);
*                }
*                .qeval = Quick.MaybeEv { return Quick.qListLitEval(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitListLit(this); }
* CSArgs      := start=@ head=Expr tail={_ ',' exp=Expr}* end=@
*                .evalfn = (env:Context) => Promise<Value[]> { return csArgsEval(this); }
*                .qeval = ((env:Context) => Value[]) | null { return Quick.qCSArgsEval(this); }
*                .exprs = Expr[] { return [this.head].concat(this.tail.map((x) => x.exp)); }
* CSIDs       := head=ID tail={_ ',' id=ID}*
*                .ids = ID[] { return [this.head].concat(this.tail.map((x) => x.id)); }
* ID          := _ !{Keyword gap} start=@ id='[a-zA-Z_áéíóúÁÉÍÓÚ][a-zA-Z_áéíóúÁÉÍÓÚ0-9]*' end=@
*                .evalfn = EvalFn { return qEvalToEval(Quick.qIdEval(this)); }
*                .qeval = Quick.EvalFn { return Quick.qIdEval(this); }
*                .accept = Acceptor { return <T>(v: ASTVisitor<T>) => v.visitID(this); }
*                .depth = PossibleResolution { return {resolved: false}; }
* Bool        := _ bool='f[ií]or|br[eé]ag'
*                .evalfn = EvalFn { return qEvalToEval(Quick.qBoolEval(this.bool)); }
*                .qeval = Quick.EvalFn { return Quick.qBoolEval(this.bool); }
* Neamhni     := _ 'neamhn[ií]'
*                .evalfn = EvalFn { return () => Promise.resolve(null); }
*                .qeval = Quick.EvalFn { return () => null; }
* Int         := _ int='-?[0-9]+(?:\.[0-9]+)?'
*                .evalfn = EvalFn { return qEvalToEval(Quick.qIntEval(this.int)); }
*                .qeval = Quick.EvalFn { return Quick.qIntEval(this.int); }
* Teacs       := _ lit={ start=@ '\'' val='([^\'\\]|\\.)*' '\'' end=@ |
*                        start=@ '"' val='([^"\\]|\\.)*' '"' end=@ }
*                .evalfn = EvalFn { return qEvalToEval(Quick.qTéacsEval(this.lit.val, this.lit.start, this.lit.end)); }
*                .qeval = Quick.EvalFn { return Quick.qTéacsEval(this.lit.val, this.lit.start, this.lit.end); }
* _           := wspace*
* wspace      := '(?:\s|>--(?:(?!--<).)*(--<|\n|$))'
* gap         := wspace | '[^a-zA-Z0-9áéíóúÁÉÍÓÚ]' | '$'
* PlusMinus   := '\+|-'
* AsgnOp      := '=|\+=|\*=|-=|%=|\/=|\/\/='
* MulDiv      := '\*|\/\/|%|\/'
* Compare     := '<=|>=|<|>'
* Keyword     := 'm[áa]' | 'n[oó]' | 'nuair-a' | 'f[ií]or|br[eé]ag'
*     | 'gn[ií]omh' | 'chun-cinn' | 'neamhn[ií]' | 'toradh' | 'creatlach'
*/

import { Context } from "setanta/node_build/ctx";
import { PossibleResolution, callFunc, idxList, Value } from "setanta/node_build/values";
import { unescapeChars } from "setanta/node_build/teacs";
import * as Asserts from "setanta/node_build/asserts";
import * as Checks from "setanta/node_build/checks";
import { orBinOp, orQuickBinOp, andBinOp, andQuickBinOp,
    binOpEvalFn, binOpQuickEvalFn } from "setanta/node_build/binops";
import { objLookupsEval, postfixArgsEval, csArgsEval, prefEval, EvalFn } from "setanta/node_build/evals";
import { qEvalToEval } from "setanta/node_build/evals";
import * as Quick from "setanta/node_build/quickevals";
import { ASTVisitor } from "setanta/node_build/visitor";
type Acceptor = <T>(visitor: ASTVisitor<T>) => T;

type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    Program = "Program",
    AsgnStmt_1 = "AsgnStmt_1",
    AsgnStmt_2 = "AsgnStmt_2",
    AsgnStmt_3 = "AsgnStmt_3",
    AsgnStmt_4 = "AsgnStmt_4",
    AsgnStmt_5 = "AsgnStmt_5",
    AsgnStmt_6 = "AsgnStmt_6",
    AsgnStmt_7 = "AsgnStmt_7",
    AsgnStmt_8 = "AsgnStmt_8",
    AsgnStmt_9 = "AsgnStmt_9",
    AsgnStmt_10 = "AsgnStmt_10",
    AsgnStmt_11 = "AsgnStmt_11",
    AsgnStmt_12 = "AsgnStmt_12",
    NonAsgnStmt_1 = "NonAsgnStmt_1",
    NonAsgnStmt_2 = "NonAsgnStmt_2",
    NonAsgnStmt_3 = "NonAsgnStmt_3",
    NonAsgnStmt_4 = "NonAsgnStmt_4",
    NonAsgnStmt_5 = "NonAsgnStmt_5",
    NonAsgnStmt_6 = "NonAsgnStmt_6",
    NonAsgnStmt_7 = "NonAsgnStmt_7",
    NonAsgnStmt_8 = "NonAsgnStmt_8",
    NonAsgnStmt_9 = "NonAsgnStmt_9",
    IfStmt = "IfStmt",
    IfStmt_$0 = "IfStmt_$0",
    BlockStmt = "BlockStmt",
    NuairStmt = "NuairStmt",
    LeStmt = "LeStmt",
    LeStmt_$0 = "LeStmt_$0",
    DefnStmt = "DefnStmt",
    AssgnStmt = "AssgnStmt",
    GniomhStmt = "GniomhStmt",
    CtlchStmt = "CtlchStmt",
    CtlchStmt_$0 = "CtlchStmt_$0",
    BrisStmt = "BrisStmt",
    CCStmt = "CCStmt",
    ToradhStmt = "ToradhStmt",
    Expr = "Expr",
    And = "And",
    And_$0 = "And_$0",
    Or = "Or",
    Or_$0 = "Or_$0",
    Eq = "Eq",
    Eq_$0 = "Eq_$0",
    Comp = "Comp",
    Comp_$0 = "Comp_$0",
    Sum = "Sum",
    Sum_$0 = "Sum_$0",
    Product = "Product",
    Product_$0 = "Product_$0",
    Prefix = "Prefix",
    Postfix = "Postfix",
    ObjLookups = "ObjLookups",
    ObjLookups_$0 = "ObjLookups_$0",
    PostOp_1 = "PostOp_1",
    PostOp_2 = "PostOp_2",
    Atom_1 = "Atom_1",
    Atom_2 = "Atom_2",
    Atom_3 = "Atom_3",
    Atom_4 = "Atom_4",
    Atom_5 = "Atom_5",
    Atom_6 = "Atom_6",
    Atom_7 = "Atom_7",
    Atom_8 = "Atom_8",
    GniomhExpr = "GniomhExpr",
    ListLit = "ListLit",
    CSArgs = "CSArgs",
    CSArgs_$0 = "CSArgs_$0",
    CSIDs = "CSIDs",
    CSIDs_$0 = "CSIDs_$0",
    ID = "ID",
    ID_$0 = "ID_$0",
    Bool = "Bool",
    Neamhni = "Neamhni",
    Int = "Int",
    Teacs = "Teacs",
    Teacs_$0_1 = "Teacs_$0_1",
    Teacs_$0_2 = "Teacs_$0_2",
    _ = "_",
    wspace = "wspace",
    gap_1 = "gap_1",
    gap_2 = "gap_2",
    gap_3 = "gap_3",
    PlusMinus = "PlusMinus",
    AsgnOp = "AsgnOp",
    MulDiv = "MulDiv",
    Compare = "Compare",
    Keyword_1 = "Keyword_1",
    Keyword_2 = "Keyword_2",
    Keyword_3 = "Keyword_3",
    Keyword_4 = "Keyword_4",
    Keyword_5 = "Keyword_5",
    Keyword_6 = "Keyword_6",
    Keyword_7 = "Keyword_7",
    Keyword_8 = "Keyword_8",
    Keyword_9 = "Keyword_9",
}
export interface Program {
    kind: ASTKinds.Program;
    stmts: AsgnStmt[];
}
export type AsgnStmt = AsgnStmt_1 | AsgnStmt_2 | AsgnStmt_3 | AsgnStmt_4 | AsgnStmt_5 | AsgnStmt_6 | AsgnStmt_7 | AsgnStmt_8 | AsgnStmt_9 | AsgnStmt_10 | AsgnStmt_11 | AsgnStmt_12;
export type AsgnStmt_1 = IfStmt;
export type AsgnStmt_2 = BlockStmt;
export type AsgnStmt_3 = NuairStmt;
export type AsgnStmt_4 = LeStmt;
export type AsgnStmt_5 = CCStmt;
export type AsgnStmt_6 = BrisStmt;
export type AsgnStmt_7 = CtlchStmt;
export type AsgnStmt_8 = GniomhStmt;
export type AsgnStmt_9 = ToradhStmt;
export type AsgnStmt_10 = AssgnStmt;
export type AsgnStmt_11 = DefnStmt;
export type AsgnStmt_12 = Expr;
export type NonAsgnStmt = NonAsgnStmt_1 | NonAsgnStmt_2 | NonAsgnStmt_3 | NonAsgnStmt_4 | NonAsgnStmt_5 | NonAsgnStmt_6 | NonAsgnStmt_7 | NonAsgnStmt_8 | NonAsgnStmt_9;
export type NonAsgnStmt_1 = IfStmt;
export type NonAsgnStmt_2 = NuairStmt;
export type NonAsgnStmt_3 = LeStmt;
export type NonAsgnStmt_4 = CCStmt;
export type NonAsgnStmt_5 = BrisStmt;
export type NonAsgnStmt_6 = ToradhStmt;
export type NonAsgnStmt_7 = BlockStmt;
export type NonAsgnStmt_8 = AssgnStmt;
export type NonAsgnStmt_9 = Expr;
export class IfStmt {
    public kind: ASTKinds.IfStmt = ASTKinds.IfStmt;
    public expr: Expr;
    public stmt: NonAsgnStmt;
    public elsebranch: Nullable<IfStmt_$0>;
    public accept: Acceptor;
    constructor(expr: Expr, stmt: NonAsgnStmt, elsebranch: Nullable<IfStmt_$0>){
        this.expr = expr;
        this.stmt = stmt;
        this.elsebranch = elsebranch;
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitIfStmt(this);
        })();
    }
}
export interface IfStmt_$0 {
    kind: ASTKinds.IfStmt_$0;
    stmt: NonAsgnStmt;
}
export class BlockStmt {
    public kind: ASTKinds.BlockStmt = ASTKinds.BlockStmt;
    public blk: AsgnStmt[];
    public accept: Acceptor;
    constructor(blk: AsgnStmt[]){
        this.blk = blk;
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitBlockStmt(this);
        })();
    }
}
export class NuairStmt {
    public kind: ASTKinds.NuairStmt = ASTKinds.NuairStmt;
    public expr: Expr;
    public stmt: NonAsgnStmt;
    public accept: Acceptor;
    constructor(expr: Expr, stmt: NonAsgnStmt){
        this.expr = expr;
        this.stmt = stmt;
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitNuairStmt(this);
        })();
    }
}
export class LeStmt {
    public kind: ASTKinds.LeStmt = ASTKinds.LeStmt;
    public id: ID;
    public strt: Expr;
    public end: Expr;
    public step: Nullable<LeStmt_$0>;
    public stmt: NonAsgnStmt;
    public accept: Acceptor;
    constructor(id: ID, strt: Expr, end: Expr, step: Nullable<LeStmt_$0>, stmt: NonAsgnStmt){
        this.id = id;
        this.strt = strt;
        this.end = end;
        this.step = step;
        this.stmt = stmt;
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitLeStmt(this);
        })();
    }
}
export interface LeStmt_$0 {
    kind: ASTKinds.LeStmt_$0;
    step: Expr;
}
export class DefnStmt {
    public kind: ASTKinds.DefnStmt = ASTKinds.DefnStmt;
    public idstart: PosInfo;
    public id: ID;
    public idend: PosInfo;
    public expr: Expr;
    public accept: Acceptor;
    constructor(idstart: PosInfo, id: ID, idend: PosInfo, expr: Expr){
        this.idstart = idstart;
        this.id = id;
        this.idend = idend;
        this.expr = expr;
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitDefnStmt(this);
        })();
    }
}
export class AssgnStmt {
    public kind: ASTKinds.AssgnStmt = ASTKinds.AssgnStmt;
    public lstart: PosInfo;
    public lhs: Postfix;
    public lend: PosInfo;
    public op: AsgnOp;
    public expr: Expr;
    public accept: Acceptor;
    constructor(lstart: PosInfo, lhs: Postfix, lend: PosInfo, op: AsgnOp, expr: Expr){
        this.lstart = lstart;
        this.lhs = lhs;
        this.lend = lend;
        this.op = op;
        this.expr = expr;
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitAssgnStmt(this);
        })();
    }
}
export class GniomhStmt {
    public kind: ASTKinds.GniomhStmt = ASTKinds.GniomhStmt;
    public id: ID;
    public args: Nullable<CSIDs>;
    public stmts: AsgnStmt[];
    public accept: Acceptor;
    constructor(id: ID, args: Nullable<CSIDs>, stmts: AsgnStmt[]){
        this.id = id;
        this.args = args;
        this.stmts = stmts;
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitGniomhStmt(this);
        })();
    }
}
export class CtlchStmt {
    public kind: ASTKinds.CtlchStmt = ASTKinds.CtlchStmt;
    public id: ID;
    public tuis: Nullable<CtlchStmt_$0>;
    public gniomhs: GniomhStmt[];
    public accept: Acceptor;
    constructor(id: ID, tuis: Nullable<CtlchStmt_$0>, gniomhs: GniomhStmt[]){
        this.id = id;
        this.tuis = tuis;
        this.gniomhs = gniomhs;
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitCtlchStmt(this);
        })();
    }
}
export interface CtlchStmt_$0 {
    kind: ASTKinds.CtlchStmt_$0;
    parentstart: PosInfo;
    id: ID;
    parentend: PosInfo;
}
export interface BrisStmt {
    kind: ASTKinds.BrisStmt;
}
export interface CCStmt {
    kind: ASTKinds.CCStmt;
}
export class ToradhStmt {
    public kind: ASTKinds.ToradhStmt = ASTKinds.ToradhStmt;
    public exp: Nullable<Expr>;
    public accept: Acceptor;
    constructor(exp: Nullable<Expr>){
        this.exp = exp;
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitToradhStmt(this);
        })();
    }
}
export type Expr = And;
export class And {
    public kind: ASTKinds.And = ASTKinds.And;
    public start: PosInfo;
    public head: Or;
    public tail: And_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(start: PosInfo, head: Or, tail: And_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return andBinOp(this);
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return andQuickBinOp(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitAnd(this);
        })();
    }
}
export interface And_$0 {
    kind: ASTKinds.And_$0;
    trm: Or;
}
export class Or {
    public kind: ASTKinds.Or = ASTKinds.Or;
    public start: PosInfo;
    public head: Eq;
    public tail: Or_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(start: PosInfo, head: Eq, tail: Or_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return orBinOp(this)
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return orQuickBinOp(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitOr(this);
        })();
    }
}
export interface Or_$0 {
    kind: ASTKinds.Or_$0;
    trm: Eq;
}
export class Eq {
    public kind: ASTKinds.Eq = ASTKinds.Eq;
    public start: PosInfo;
    public head: Comp;
    public tail: Eq_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(start: PosInfo, head: Comp, tail: Eq_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return binOpEvalFn(this)
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return binOpQuickEvalFn(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitEq(this);
        })();
    }
}
export interface Eq_$0 {
    kind: ASTKinds.Eq_$0;
    op: string;
    trm: Comp;
}
export class Comp {
    public kind: ASTKinds.Comp = ASTKinds.Comp;
    public start: PosInfo;
    public head: Sum;
    public tail: Comp_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(start: PosInfo, head: Sum, tail: Comp_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return binOpEvalFn(this)
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return binOpQuickEvalFn(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitComp(this);
        })();
    }
}
export interface Comp_$0 {
    kind: ASTKinds.Comp_$0;
    op: Compare;
    trm: Sum;
}
export class Sum {
    public kind: ASTKinds.Sum = ASTKinds.Sum;
    public start: PosInfo;
    public head: Product;
    public tail: Sum_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(start: PosInfo, head: Product, tail: Sum_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return binOpEvalFn(this)
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return binOpQuickEvalFn(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitSum(this);
        })();
    }
}
export interface Sum_$0 {
    kind: ASTKinds.Sum_$0;
    op: PlusMinus;
    trm: Product;
}
export class Product {
    public kind: ASTKinds.Product = ASTKinds.Product;
    public start: PosInfo;
    public head: Prefix;
    public tail: Product_$0[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(start: PosInfo, head: Prefix, tail: Product_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return binOpEvalFn(this);
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return binOpQuickEvalFn(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitProduct(this);
        })();
    }
}
export interface Product_$0 {
    kind: ASTKinds.Product_$0;
    op: MulDiv;
    trm: Prefix;
}
export class Prefix {
    public kind: ASTKinds.Prefix = ASTKinds.Prefix;
    public start: PosInfo;
    public op: Nullable<string>;
    public pf: Postfix;
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    constructor(start: PosInfo, op: Nullable<string>, pf: Postfix, end: PosInfo){
        this.start = start;
        this.op = op;
        this.pf = pf;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return prefEval(this);
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return Quick.qPrefEval(this);
        })();
    }
}
export class Postfix {
    public kind: ASTKinds.Postfix = ASTKinds.Postfix;
    public start: PosInfo;
    public at: ObjLookups;
    public ops: PostOp[];
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(start: PosInfo, at: ObjLookups, ops: PostOp[], end: PosInfo){
        this.start = start;
        this.at = at;
        this.ops = ops;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return postfixArgsEval(this);
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return Quick.qPostfixArgsEval(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitPostfix(this);
        })();
    }
}
export class ObjLookups {
    public kind: ASTKinds.ObjLookups = ASTKinds.ObjLookups;
    public start: PosInfo;
    public attrs: ObjLookups_$0[];
    public root: Atom;
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(start: PosInfo, attrs: ObjLookups_$0[], root: Atom, end: PosInfo){
        this.start = start;
        this.attrs = attrs;
        this.root = root;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return objLookupsEval(this);
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return Quick.qObjLookupsEval(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitObjLookups(this);
        })();
    }
}
export interface ObjLookups_$0 {
    kind: ASTKinds.ObjLookups_$0;
    id: ID;
}
export type PostOp = PostOp_1 | PostOp_2;
export interface PostOp_1 {
    kind: ASTKinds.PostOp_1;
    args: Nullable<CSArgs>;
}
export interface PostOp_2 {
    kind: ASTKinds.PostOp_2;
    expr: Expr;
}
export type Atom = Atom_1 | Atom_2 | Atom_3 | Atom_4 | Atom_5 | Atom_6 | Atom_7 | Atom_8;
export class Atom_1 {
    public kind: ASTKinds.Atom_1 = ASTKinds.Atom_1;
    public trm: Expr;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(trm: Expr){
        this.trm = trm;
        this.evalfn = ((): EvalFn => {
        return (env: Context) => this.trm.evalfn(env);
        })();
        this.qeval = ((): Quick.MaybeEv => {
        const childF = this.trm.qeval;
                    return childF === null ? null : childF.bind(this.trm);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitExpr(this.trm);
        })();
    }
}
export type Atom_2 = ID;
export type Atom_3 = Teacs;
export type Atom_4 = Int;
export type Atom_5 = Bool;
export type Atom_6 = Neamhni;
export type Atom_7 = ListLit;
export type Atom_8 = GniomhExpr;
export class GniomhExpr {
    public kind: ASTKinds.GniomhExpr = ASTKinds.GniomhExpr;
    public args: Nullable<CSIDs>;
    public stmts: AsgnStmt[];
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    public accept: Acceptor;
    constructor(args: Nullable<CSIDs>, stmts: AsgnStmt[]){
        this.args = args;
        this.stmts = stmts;
        this.evalfn = ((): EvalFn => {
        return qEvalToEval(Quick.qGníomhEval(this));
        })();
        this.qeval = ((): Quick.EvalFn => {
        return Quick.qGníomhEval(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitGniomhExpr(this);
        })();
    }
}
export class ListLit {
    public kind: ASTKinds.ListLit = ASTKinds.ListLit;
    public els: Nullable<CSArgs>;
    public evalfn: EvalFn;
    public qeval: Quick.MaybeEv;
    public accept: Acceptor;
    constructor(els: Nullable<CSArgs>){
        this.els = els;
        this.evalfn = ((): EvalFn => {
        return (env: Context) => this.els ? this.els.evalfn(env) : Promise.resolve([]);
        })();
        this.qeval = ((): Quick.MaybeEv => {
        return Quick.qListLitEval(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitListLit(this);
        })();
    }
}
export class CSArgs {
    public kind: ASTKinds.CSArgs = ASTKinds.CSArgs;
    public start: PosInfo;
    public head: Expr;
    public tail: CSArgs_$0[];
    public end: PosInfo;
    public evalfn: (env:Context) => Promise<Value[]>;
    public qeval: ((env:Context) => Value[]) | null;
    public exprs: Expr[];
    constructor(start: PosInfo, head: Expr, tail: CSArgs_$0[], end: PosInfo){
        this.start = start;
        this.head = head;
        this.tail = tail;
        this.end = end;
        this.evalfn = ((): (env:Context) => Promise<Value[]> => {
        return csArgsEval(this);
        })();
        this.qeval = ((): ((env:Context) => Value[]) | null => {
        return Quick.qCSArgsEval(this);
        })();
        this.exprs = ((): Expr[] => {
        return [this.head].concat(this.tail.map((x) => x.exp));
        })();
    }
}
export interface CSArgs_$0 {
    kind: ASTKinds.CSArgs_$0;
    exp: Expr;
}
export class CSIDs {
    public kind: ASTKinds.CSIDs = ASTKinds.CSIDs;
    public head: ID;
    public tail: CSIDs_$0[];
    public ids: ID[];
    constructor(head: ID, tail: CSIDs_$0[]){
        this.head = head;
        this.tail = tail;
        this.ids = ((): ID[] => {
        return [this.head].concat(this.tail.map((x) => x.id));
        })();
    }
}
export interface CSIDs_$0 {
    kind: ASTKinds.CSIDs_$0;
    id: ID;
}
export class ID {
    public kind: ASTKinds.ID = ASTKinds.ID;
    public start: PosInfo;
    public id: string;
    public end: PosInfo;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    public accept: Acceptor;
    public depth: PossibleResolution;
    constructor(start: PosInfo, id: string, end: PosInfo){
        this.start = start;
        this.id = id;
        this.end = end;
        this.evalfn = ((): EvalFn => {
        return qEvalToEval(Quick.qIdEval(this));
        })();
        this.qeval = ((): Quick.EvalFn => {
        return Quick.qIdEval(this);
        })();
        this.accept = ((): Acceptor => {
        return <T>(v: ASTVisitor<T>) => v.visitID(this);
        })();
        this.depth = ((): PossibleResolution => {
        return {resolved: false};
        })();
    }
}
export interface ID_$0 {
    kind: ASTKinds.ID_$0;
}
export class Bool {
    public kind: ASTKinds.Bool = ASTKinds.Bool;
    public bool: string;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(bool: string){
        this.bool = bool;
        this.evalfn = ((): EvalFn => {
        return qEvalToEval(Quick.qBoolEval(this.bool));
        })();
        this.qeval = ((): Quick.EvalFn => {
        return Quick.qBoolEval(this.bool);
        })();
    }
}
export class Neamhni {
    public kind: ASTKinds.Neamhni = ASTKinds.Neamhni;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(){
        this.evalfn = ((): EvalFn => {
        return () => Promise.resolve(null);
        })();
        this.qeval = ((): Quick.EvalFn => {
        return () => null;
        })();
    }
}
export class Int {
    public kind: ASTKinds.Int = ASTKinds.Int;
    public int: string;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(int: string){
        this.int = int;
        this.evalfn = ((): EvalFn => {
        return qEvalToEval(Quick.qIntEval(this.int));
        })();
        this.qeval = ((): Quick.EvalFn => {
        return Quick.qIntEval(this.int);
        })();
    }
}
export class Teacs {
    public kind: ASTKinds.Teacs = ASTKinds.Teacs;
    public lit: Teacs_$0;
    public evalfn: EvalFn;
    public qeval: Quick.EvalFn;
    constructor(lit: Teacs_$0){
        this.lit = lit;
        this.evalfn = ((): EvalFn => {
        return qEvalToEval(Quick.qTéacsEval(this.lit.val, this.lit.start, this.lit.end));
        })();
        this.qeval = ((): Quick.EvalFn => {
        return Quick.qTéacsEval(this.lit.val, this.lit.start, this.lit.end);
        })();
    }
}
export type Teacs_$0 = Teacs_$0_1 | Teacs_$0_2;
export interface Teacs_$0_1 {
    kind: ASTKinds.Teacs_$0_1;
    start: PosInfo;
    val: string;
    end: PosInfo;
}
export interface Teacs_$0_2 {
    kind: ASTKinds.Teacs_$0_2;
    start: PosInfo;
    val: string;
    end: PosInfo;
}
export type _ = wspace[];
export type wspace = string;
export type gap = gap_1 | gap_2 | gap_3;
export type gap_1 = wspace;
export type gap_2 = string;
export type gap_3 = string;
export type PlusMinus = string;
export type AsgnOp = string;
export type MulDiv = string;
export type Compare = string;
export type Keyword = Keyword_1 | Keyword_2 | Keyword_3 | Keyword_4 | Keyword_5 | Keyword_6 | Keyword_7 | Keyword_8 | Keyword_9;
export type Keyword_1 = string;
export type Keyword_2 = string;
export type Keyword_3 = string;
export type Keyword_4 = string;
export type Keyword_5 = string;
export type Keyword_6 = string;
export type Keyword_7 = string;
export type Keyword_8 = string;
export type Keyword_9 = string;
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
    }
    public matchProgram($$dpth: number, $$cr?: ErrorTracker): Nullable<Program> {
        return this.run<Program>($$dpth,
            () => {
                let $scope$stmts: Nullable<AsgnStmt[]>;
                let $$res: Nullable<Program> = null;
                if (true
                    && ($scope$stmts = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.Program, stmts: $scope$stmts};
                }
                return $$res;
            });
    }
    public matchAsgnStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt> {
        return this.choice<AsgnStmt>([
            () => this.matchAsgnStmt_1($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_2($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_3($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_4($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_5($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_6($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_7($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_8($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_9($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_10($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_11($$dpth + 1, $$cr),
            () => this.matchAsgnStmt_12($$dpth + 1, $$cr),
        ]);
    }
    public matchAsgnStmt_1($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_2($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_2> {
        return this.matchBlockStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_3($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_3> {
        return this.matchNuairStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_4($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_4> {
        return this.matchLeStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_5($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_5> {
        return this.matchCCStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_6($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_6> {
        return this.matchBrisStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_7($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_7> {
        return this.matchCtlchStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_8($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_8> {
        return this.matchGniomhStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_9($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_9> {
        return this.matchToradhStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_10($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_10> {
        return this.matchAssgnStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_11($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_11> {
        return this.matchDefnStmt($$dpth + 1, $$cr);
    }
    public matchAsgnStmt_12($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnStmt_12> {
        return this.matchExpr($$dpth + 1, $$cr);
    }
    public matchNonAsgnStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt> {
        return this.choice<NonAsgnStmt>([
            () => this.matchNonAsgnStmt_1($$dpth + 1, $$cr),
            () => this.matchNonAsgnStmt_2($$dpth + 1, $$cr),
            () => this.matchNonAsgnStmt_3($$dpth + 1, $$cr),
            () => this.matchNonAsgnStmt_4($$dpth + 1, $$cr),
            () => this.matchNonAsgnStmt_5($$dpth + 1, $$cr),
            () => this.matchNonAsgnStmt_6($$dpth + 1, $$cr),
            () => this.matchNonAsgnStmt_7($$dpth + 1, $$cr),
            () => this.matchNonAsgnStmt_8($$dpth + 1, $$cr),
            () => this.matchNonAsgnStmt_9($$dpth + 1, $$cr),
        ]);
    }
    public matchNonAsgnStmt_1($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt_1> {
        return this.matchIfStmt($$dpth + 1, $$cr);
    }
    public matchNonAsgnStmt_2($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt_2> {
        return this.matchNuairStmt($$dpth + 1, $$cr);
    }
    public matchNonAsgnStmt_3($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt_3> {
        return this.matchLeStmt($$dpth + 1, $$cr);
    }
    public matchNonAsgnStmt_4($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt_4> {
        return this.matchCCStmt($$dpth + 1, $$cr);
    }
    public matchNonAsgnStmt_5($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt_5> {
        return this.matchBrisStmt($$dpth + 1, $$cr);
    }
    public matchNonAsgnStmt_6($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt_6> {
        return this.matchToradhStmt($$dpth + 1, $$cr);
    }
    public matchNonAsgnStmt_7($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt_7> {
        return this.matchBlockStmt($$dpth + 1, $$cr);
    }
    public matchNonAsgnStmt_8($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt_8> {
        return this.matchAssgnStmt($$dpth + 1, $$cr);
    }
    public matchNonAsgnStmt_9($$dpth: number, $$cr?: ErrorTracker): Nullable<NonAsgnStmt_9> {
        return this.matchExpr($$dpth + 1, $$cr);
    }
    public matchIfStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<IfStmt> {
        return this.run<IfStmt>($$dpth,
            () => {
                let $scope$expr: Nullable<Expr>;
                let $scope$stmt: Nullable<NonAsgnStmt>;
                let $scope$elsebranch: Nullable<Nullable<IfStmt_$0>>;
                let $$res: Nullable<IfStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:m[áa])`, $$dpth + 1, $$cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, $$cr)) !== null
                    && ($scope$expr = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, $$cr)) !== null
                    && ($scope$stmt = this.matchNonAsgnStmt($$dpth + 1, $$cr)) !== null
                    && (($scope$elsebranch = this.matchIfStmt_$0($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = new IfStmt($scope$expr, $scope$stmt, $scope$elsebranch);
                }
                return $$res;
            });
    }
    public matchIfStmt_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<IfStmt_$0> {
        return this.run<IfStmt_$0>($$dpth,
            () => {
                let $scope$stmt: Nullable<NonAsgnStmt>;
                let $$res: Nullable<IfStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:n[oó])`, $$dpth + 1, $$cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, $$cr)) !== null
                    && ($scope$stmt = this.matchNonAsgnStmt($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.IfStmt_$0, stmt: $scope$stmt};
                }
                return $$res;
            });
    }
    public matchBlockStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<BlockStmt> {
        return this.run<BlockStmt>($$dpth,
            () => {
                let $scope$blk: Nullable<AsgnStmt[]>;
                let $$res: Nullable<BlockStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:{)`, $$dpth + 1, $$cr) !== null
                    && ($scope$blk = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:})`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = new BlockStmt($scope$blk);
                }
                return $$res;
            });
    }
    public matchNuairStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<NuairStmt> {
        return this.run<NuairStmt>($$dpth,
            () => {
                let $scope$expr: Nullable<Expr>;
                let $scope$stmt: Nullable<NonAsgnStmt>;
                let $$res: Nullable<NuairStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:nuair-a)`, $$dpth + 1, $$cr) !== null
                    && ($scope$expr = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, $$cr)) !== null
                    && ($scope$stmt = this.matchNonAsgnStmt($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new NuairStmt($scope$expr, $scope$stmt);
                }
                return $$res;
            });
    }
    public matchLeStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<LeStmt> {
        return this.run<LeStmt>($$dpth,
            () => {
                let $scope$id: Nullable<ID>;
                let $scope$strt: Nullable<Expr>;
                let $scope$end: Nullable<Expr>;
                let $scope$step: Nullable<Nullable<LeStmt_$0>>;
                let $scope$stmt: Nullable<NonAsgnStmt>;
                let $$res: Nullable<LeStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:le)`, $$dpth + 1, $$cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, $$cr)) !== null
                    && ($scope$id = this.matchID($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:idir)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && ($scope$strt = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && ($scope$end = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && (($scope$step = this.matchLeStmt_$0($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                    && ($scope$stmt = this.matchNonAsgnStmt($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new LeStmt($scope$id, $scope$strt, $scope$end, $scope$step, $scope$stmt);
                }
                return $$res;
            });
    }
    public matchLeStmt_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<LeStmt_$0> {
        return this.run<LeStmt_$0>($$dpth,
            () => {
                let $scope$step: Nullable<Expr>;
                let $$res: Nullable<LeStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && ($scope$step = this.matchExpr($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.LeStmt_$0, step: $scope$step};
                }
                return $$res;
            });
    }
    public matchDefnStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<DefnStmt> {
        return this.run<DefnStmt>($$dpth,
            () => {
                let $scope$idstart: Nullable<PosInfo>;
                let $scope$id: Nullable<ID>;
                let $scope$idend: Nullable<PosInfo>;
                let $scope$expr: Nullable<Expr>;
                let $$res: Nullable<DefnStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$idstart = this.mark()) !== null
                    && ($scope$id = this.matchID($$dpth + 1, $$cr)) !== null
                    && ($scope$idend = this.mark()) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?::=)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expr = this.matchExpr($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new DefnStmt($scope$idstart, $scope$id, $scope$idend, $scope$expr);
                }
                return $$res;
            });
    }
    public matchAssgnStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<AssgnStmt> {
        return this.run<AssgnStmt>($$dpth,
            () => {
                let $scope$lstart: Nullable<PosInfo>;
                let $scope$lhs: Nullable<Postfix>;
                let $scope$lend: Nullable<PosInfo>;
                let $scope$op: Nullable<AsgnOp>;
                let $scope$expr: Nullable<Expr>;
                let $$res: Nullable<AssgnStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$lstart = this.mark()) !== null
                    && ($scope$lhs = this.matchPostfix($$dpth + 1, $$cr)) !== null
                    && ($scope$lend = this.mark()) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$op = this.matchAsgnOp($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expr = this.matchExpr($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new AssgnStmt($scope$lstart, $scope$lhs, $scope$lend, $scope$op, $scope$expr);
                }
                return $$res;
            });
    }
    public matchGniomhStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<GniomhStmt> {
        return this.run<GniomhStmt>($$dpth,
            () => {
                let $scope$id: Nullable<ID>;
                let $scope$args: Nullable<Nullable<CSIDs>>;
                let $scope$stmts: Nullable<AsgnStmt[]>;
                let $$res: Nullable<GniomhStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:gn[íi]omh)`, $$dpth + 1, $$cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, $$cr)) !== null
                    && ($scope$id = this.matchID($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && (($scope$args = this.matchCSIDs($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:{)`, $$dpth + 1, $$cr) !== null
                    && ($scope$stmts = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:})`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = new GniomhStmt($scope$id, $scope$args, $scope$stmts);
                }
                return $$res;
            });
    }
    public matchCtlchStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<CtlchStmt> {
        return this.run<CtlchStmt>($$dpth,
            () => {
                let $scope$id: Nullable<ID>;
                let $scope$tuis: Nullable<Nullable<CtlchStmt_$0>>;
                let $scope$gniomhs: Nullable<GniomhStmt[]>;
                let $$res: Nullable<CtlchStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:creatlach)`, $$dpth + 1, $$cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, $$cr)) !== null
                    && ($scope$id = this.matchID($$dpth + 1, $$cr)) !== null
                    && (($scope$tuis = this.matchCtlchStmt_$0($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:{)`, $$dpth + 1, $$cr) !== null
                    && ($scope$gniomhs = this.loop<GniomhStmt>(() => this.matchGniomhStmt($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:})`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = new CtlchStmt($scope$id, $scope$tuis, $scope$gniomhs);
                }
                return $$res;
            });
    }
    public matchCtlchStmt_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<CtlchStmt_$0> {
        return this.run<CtlchStmt_$0>($$dpth,
            () => {
                let $scope$parentstart: Nullable<PosInfo>;
                let $scope$id: Nullable<ID>;
                let $scope$parentend: Nullable<PosInfo>;
                let $$res: Nullable<CtlchStmt_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:ó)`, $$dpth + 1, $$cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, $$cr)) !== null
                    && ($scope$parentstart = this.mark()) !== null
                    && ($scope$id = this.matchID($$dpth + 1, $$cr)) !== null
                    && ($scope$parentend = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.CtlchStmt_$0, parentstart: $scope$parentstart, id: $scope$id, parentend: $scope$parentend};
                }
                return $$res;
            });
    }
    public matchBrisStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<BrisStmt> {
        return this.run<BrisStmt>($$dpth,
            () => {
                let $$res: Nullable<BrisStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:bris)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.BrisStmt, };
                }
                return $$res;
            });
    }
    public matchCCStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<CCStmt> {
        return this.run<CCStmt>($$dpth,
            () => {
                let $$res: Nullable<CCStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:chun-cinn)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.CCStmt, };
                }
                return $$res;
            });
    }
    public matchToradhStmt($$dpth: number, $$cr?: ErrorTracker): Nullable<ToradhStmt> {
        return this.run<ToradhStmt>($$dpth,
            () => {
                let $scope$exp: Nullable<Nullable<Expr>>;
                let $$res: Nullable<ToradhStmt> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:toradh)`, $$dpth + 1, $$cr) !== null
                    && this.noConsume<gap>(() => this.matchgap($$dpth + 1, $$cr)) !== null
                    && (($scope$exp = this.matchExpr($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = new ToradhStmt($scope$exp);
                }
                return $$res;
            });
    }
    public matchExpr($$dpth: number, $$cr?: ErrorTracker): Nullable<Expr> {
        return this.matchAnd($$dpth + 1, $$cr);
    }
    public matchAnd($$dpth: number, $$cr?: ErrorTracker): Nullable<And> {
        return this.run<And>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$head: Nullable<Or>;
                let $scope$tail: Nullable<And_$0[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<And> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$head = this.matchOr($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<And_$0>(() => this.matchAnd_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new And($scope$start, $scope$head, $scope$tail, $scope$end);
                }
                return $$res;
            });
    }
    public matchAnd_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<And_$0> {
        return this.run<And_$0>($$dpth,
            () => {
                let $scope$trm: Nullable<Or>;
                let $$res: Nullable<And_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\&)`, $$dpth + 1, $$cr) !== null
                    && ($scope$trm = this.matchOr($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.And_$0, trm: $scope$trm};
                }
                return $$res;
            });
    }
    public matchOr($$dpth: number, $$cr?: ErrorTracker): Nullable<Or> {
        return this.run<Or>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$head: Nullable<Eq>;
                let $scope$tail: Nullable<Or_$0[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Or> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$head = this.matchEq($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<Or_$0>(() => this.matchOr_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Or($scope$start, $scope$head, $scope$tail, $scope$end);
                }
                return $$res;
            });
    }
    public matchOr_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Or_$0> {
        return this.run<Or_$0>($$dpth,
            () => {
                let $scope$trm: Nullable<Eq>;
                let $$res: Nullable<Or_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\|)`, $$dpth + 1, $$cr) !== null
                    && ($scope$trm = this.matchEq($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Or_$0, trm: $scope$trm};
                }
                return $$res;
            });
    }
    public matchEq($$dpth: number, $$cr?: ErrorTracker): Nullable<Eq> {
        return this.run<Eq>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$head: Nullable<Comp>;
                let $scope$tail: Nullable<Eq_$0[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Eq> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$head = this.matchComp($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<Eq_$0>(() => this.matchEq_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Eq($scope$start, $scope$head, $scope$tail, $scope$end);
                }
                return $$res;
            });
    }
    public matchEq_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Eq_$0> {
        return this.run<Eq_$0>($$dpth,
            () => {
                let $scope$op: Nullable<string>;
                let $scope$trm: Nullable<Comp>;
                let $$res: Nullable<Eq_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$op = this.regexAccept(String.raw`(?:[!=]=)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$trm = this.matchComp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Eq_$0, op: $scope$op, trm: $scope$trm};
                }
                return $$res;
            });
    }
    public matchComp($$dpth: number, $$cr?: ErrorTracker): Nullable<Comp> {
        return this.run<Comp>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$head: Nullable<Sum>;
                let $scope$tail: Nullable<Comp_$0[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Comp> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$head = this.matchSum($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<Comp_$0>(() => this.matchComp_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Comp($scope$start, $scope$head, $scope$tail, $scope$end);
                }
                return $$res;
            });
    }
    public matchComp_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Comp_$0> {
        return this.run<Comp_$0>($$dpth,
            () => {
                let $scope$op: Nullable<Compare>;
                let $scope$trm: Nullable<Sum>;
                let $$res: Nullable<Comp_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$op = this.matchCompare($$dpth + 1, $$cr)) !== null
                    && ($scope$trm = this.matchSum($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Comp_$0, op: $scope$op, trm: $scope$trm};
                }
                return $$res;
            });
    }
    public matchSum($$dpth: number, $$cr?: ErrorTracker): Nullable<Sum> {
        return this.run<Sum>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$head: Nullable<Product>;
                let $scope$tail: Nullable<Sum_$0[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Sum> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$head = this.matchProduct($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<Sum_$0>(() => this.matchSum_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Sum($scope$start, $scope$head, $scope$tail, $scope$end);
                }
                return $$res;
            });
    }
    public matchSum_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Sum_$0> {
        return this.run<Sum_$0>($$dpth,
            () => {
                let $scope$op: Nullable<PlusMinus>;
                let $scope$trm: Nullable<Product>;
                let $$res: Nullable<Sum_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$op = this.matchPlusMinus($$dpth + 1, $$cr)) !== null
                    && ($scope$trm = this.matchProduct($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Sum_$0, op: $scope$op, trm: $scope$trm};
                }
                return $$res;
            });
    }
    public matchProduct($$dpth: number, $$cr?: ErrorTracker): Nullable<Product> {
        return this.run<Product>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$head: Nullable<Prefix>;
                let $scope$tail: Nullable<Product_$0[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Product> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$head = this.matchPrefix($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<Product_$0>(() => this.matchProduct_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Product($scope$start, $scope$head, $scope$tail, $scope$end);
                }
                return $$res;
            });
    }
    public matchProduct_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Product_$0> {
        return this.run<Product_$0>($$dpth,
            () => {
                let $scope$op: Nullable<MulDiv>;
                let $scope$trm: Nullable<Prefix>;
                let $$res: Nullable<Product_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$op = this.matchMulDiv($$dpth + 1, $$cr)) !== null
                    && ($scope$trm = this.matchPrefix($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.Product_$0, op: $scope$op, trm: $scope$trm};
                }
                return $$res;
            });
    }
    public matchPrefix($$dpth: number, $$cr?: ErrorTracker): Nullable<Prefix> {
        return this.run<Prefix>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$op: Nullable<Nullable<string>>;
                let $scope$pf: Nullable<Postfix>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Prefix> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$start = this.mark()) !== null
                    && (($scope$op = this.regexAccept(String.raw`(?:-|!)`, $$dpth + 1, $$cr)) || true)
                    && ($scope$pf = this.matchPostfix($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Prefix($scope$start, $scope$op, $scope$pf, $scope$end);
                }
                return $$res;
            });
    }
    public matchPostfix($$dpth: number, $$cr?: ErrorTracker): Nullable<Postfix> {
        return this.run<Postfix>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$at: Nullable<ObjLookups>;
                let $scope$ops: Nullable<PostOp[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Postfix> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$at = this.matchObjLookups($$dpth + 1, $$cr)) !== null
                    && ($scope$ops = this.loop<PostOp>(() => this.matchPostOp($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new Postfix($scope$start, $scope$at, $scope$ops, $scope$end);
                }
                return $$res;
            });
    }
    public matchObjLookups($$dpth: number, $$cr?: ErrorTracker): Nullable<ObjLookups> {
        return this.run<ObjLookups>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$attrs: Nullable<ObjLookups_$0[]>;
                let $scope$root: Nullable<Atom>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<ObjLookups> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$attrs = this.loop<ObjLookups_$0>(() => this.matchObjLookups_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$root = this.matchAtom($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new ObjLookups($scope$start, $scope$attrs, $scope$root, $scope$end);
                }
                return $$res;
            });
    }
    public matchObjLookups_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<ObjLookups_$0> {
        return this.run<ObjLookups_$0>($$dpth,
            () => {
                let $scope$id: Nullable<ID>;
                let $$res: Nullable<ObjLookups_$0> = null;
                if (true
                    && ($scope$id = this.matchID($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:@)`, $$dpth + 1, $$cr) !== null
                    && this.negate(() => this.matchwspace($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.ObjLookups_$0, id: $scope$id};
                }
                return $$res;
            });
    }
    public matchPostOp($$dpth: number, $$cr?: ErrorTracker): Nullable<PostOp> {
        return this.choice<PostOp>([
            () => this.matchPostOp_1($$dpth + 1, $$cr),
            () => this.matchPostOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchPostOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<PostOp_1> {
        return this.run<PostOp_1>($$dpth,
            () => {
                let $scope$args: Nullable<Nullable<CSArgs>>;
                let $$res: Nullable<PostOp_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && (($scope$args = this.matchCSArgs($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.PostOp_1, args: $scope$args};
                }
                return $$res;
            });
    }
    public matchPostOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<PostOp_2> {
        return this.run<PostOp_2>($$dpth,
            () => {
                let $scope$expr: Nullable<Expr>;
                let $$res: Nullable<PostOp_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && ($scope$expr = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.PostOp_2, expr: $scope$expr};
                }
                return $$res;
            });
    }
    public matchAtom($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom> {
        return this.choice<Atom>([
            () => this.matchAtom_1($$dpth + 1, $$cr),
            () => this.matchAtom_2($$dpth + 1, $$cr),
            () => this.matchAtom_3($$dpth + 1, $$cr),
            () => this.matchAtom_4($$dpth + 1, $$cr),
            () => this.matchAtom_5($$dpth + 1, $$cr),
            () => this.matchAtom_6($$dpth + 1, $$cr),
            () => this.matchAtom_7($$dpth + 1, $$cr),
            () => this.matchAtom_8($$dpth + 1, $$cr),
        ]);
    }
    public matchAtom_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_1> {
        return this.run<Atom_1>($$dpth,
            () => {
                let $scope$trm: Nullable<Expr>;
                let $$res: Nullable<Atom_1> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && ($scope$trm = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = new Atom_1($scope$trm);
                }
                return $$res;
            });
    }
    public matchAtom_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_2> {
        return this.matchID($$dpth + 1, $$cr);
    }
    public matchAtom_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_3> {
        return this.matchTeacs($$dpth + 1, $$cr);
    }
    public matchAtom_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_4> {
        return this.matchInt($$dpth + 1, $$cr);
    }
    public matchAtom_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_5> {
        return this.matchBool($$dpth + 1, $$cr);
    }
    public matchAtom_6($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_6> {
        return this.matchNeamhni($$dpth + 1, $$cr);
    }
    public matchAtom_7($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_7> {
        return this.matchListLit($$dpth + 1, $$cr);
    }
    public matchAtom_8($$dpth: number, $$cr?: ErrorTracker): Nullable<Atom_8> {
        return this.matchGniomhExpr($$dpth + 1, $$cr);
    }
    public matchGniomhExpr($$dpth: number, $$cr?: ErrorTracker): Nullable<GniomhExpr> {
        return this.run<GniomhExpr>($$dpth,
            () => {
                let $scope$args: Nullable<Nullable<CSIDs>>;
                let $scope$stmts: Nullable<AsgnStmt[]>;
                let $$res: Nullable<GniomhExpr> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:gn[íi]omh)`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr) !== null
                    && (($scope$args = this.matchCSIDs($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:{)`, $$dpth + 1, $$cr) !== null
                    && ($scope$stmts = this.loop<AsgnStmt>(() => this.matchAsgnStmt($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:})`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = new GniomhExpr($scope$args, $scope$stmts);
                }
                return $$res;
            });
    }
    public matchListLit($$dpth: number, $$cr?: ErrorTracker): Nullable<ListLit> {
        return this.run<ListLit>($$dpth,
            () => {
                let $scope$els: Nullable<Nullable<CSArgs>>;
                let $$res: Nullable<ListLit> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && (($scope$els = this.matchCSArgs($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = new ListLit($scope$els);
                }
                return $$res;
            });
    }
    public matchCSArgs($$dpth: number, $$cr?: ErrorTracker): Nullable<CSArgs> {
        return this.run<CSArgs>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$head: Nullable<Expr>;
                let $scope$tail: Nullable<CSArgs_$0[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<CSArgs> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$head = this.matchExpr($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<CSArgs_$0>(() => this.matchCSArgs_$0($$dpth + 1, $$cr), true)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new CSArgs($scope$start, $scope$head, $scope$tail, $scope$end);
                }
                return $$res;
            });
    }
    public matchCSArgs_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<CSArgs_$0> {
        return this.run<CSArgs_$0>($$dpth,
            () => {
                let $scope$exp: Nullable<Expr>;
                let $$res: Nullable<CSArgs_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && ($scope$exp = this.matchExpr($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.CSArgs_$0, exp: $scope$exp};
                }
                return $$res;
            });
    }
    public matchCSIDs($$dpth: number, $$cr?: ErrorTracker): Nullable<CSIDs> {
        return this.run<CSIDs>($$dpth,
            () => {
                let $scope$head: Nullable<ID>;
                let $scope$tail: Nullable<CSIDs_$0[]>;
                let $$res: Nullable<CSIDs> = null;
                if (true
                    && ($scope$head = this.matchID($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<CSIDs_$0>(() => this.matchCSIDs_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = new CSIDs($scope$head, $scope$tail);
                }
                return $$res;
            });
    }
    public matchCSIDs_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<CSIDs_$0> {
        return this.run<CSIDs_$0>($$dpth,
            () => {
                let $scope$id: Nullable<ID>;
                let $$res: Nullable<CSIDs_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && ($scope$id = this.matchID($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.CSIDs_$0, id: $scope$id};
                }
                return $$res;
            });
    }
    public matchID($$dpth: number, $$cr?: ErrorTracker): Nullable<ID> {
        return this.run<ID>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$id: Nullable<string>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<ID> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.negate(() => this.matchID_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$start = this.mark()) !== null
                    && ($scope$id = this.regexAccept(String.raw`(?:[a-zA-Z_áéíóúÁÉÍÓÚ][a-zA-Z_áéíóúÁÉÍÓÚ0-9]*)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = new ID($scope$start, $scope$id, $scope$end);
                }
                return $$res;
            });
    }
    public matchID_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<ID_$0> {
        return this.run<ID_$0>($$dpth,
            () => {
                let $$res: Nullable<ID_$0> = null;
                if (true
                    && this.matchKeyword($$dpth + 1, $$cr) !== null
                    && this.matchgap($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.ID_$0, };
                }
                return $$res;
            });
    }
    public matchBool($$dpth: number, $$cr?: ErrorTracker): Nullable<Bool> {
        return this.run<Bool>($$dpth,
            () => {
                let $scope$bool: Nullable<string>;
                let $$res: Nullable<Bool> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$bool = this.regexAccept(String.raw`(?:f[ií]or|br[eé]ag)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Bool($scope$bool);
                }
                return $$res;
            });
    }
    public matchNeamhni($$dpth: number, $$cr?: ErrorTracker): Nullable<Neamhni> {
        return this.run<Neamhni>($$dpth,
            () => {
                let $$res: Nullable<Neamhni> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:neamhn[ií])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = new Neamhni();
                }
                return $$res;
            });
    }
    public matchInt($$dpth: number, $$cr?: ErrorTracker): Nullable<Int> {
        return this.run<Int>($$dpth,
            () => {
                let $scope$int: Nullable<string>;
                let $$res: Nullable<Int> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$int = this.regexAccept(String.raw`(?:-?[0-9]+(?:\.[0-9]+)?)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Int($scope$int);
                }
                return $$res;
            });
    }
    public matchTeacs($$dpth: number, $$cr?: ErrorTracker): Nullable<Teacs> {
        return this.run<Teacs>($$dpth,
            () => {
                let $scope$lit: Nullable<Teacs_$0>;
                let $$res: Nullable<Teacs> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$lit = this.matchTeacs_$0($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = new Teacs($scope$lit);
                }
                return $$res;
            });
    }
    public matchTeacs_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<Teacs_$0> {
        return this.choice<Teacs_$0>([
            () => this.matchTeacs_$0_1($$dpth + 1, $$cr),
            () => this.matchTeacs_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchTeacs_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Teacs_$0_1> {
        return this.run<Teacs_$0_1>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$val: Nullable<string>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Teacs_$0_1> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && this.regexAccept(String.raw`(?:\')`, $$dpth + 1, $$cr) !== null
                    && ($scope$val = this.regexAccept(String.raw`(?:([^\'\\]|\\.)*)`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:\')`, $$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.Teacs_$0_1, start: $scope$start, val: $scope$val, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchTeacs_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Teacs_$0_2> {
        return this.run<Teacs_$0_2>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$val: Nullable<string>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<Teacs_$0_2> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && this.regexAccept(String.raw`(?:")`, $$dpth + 1, $$cr) !== null
                    && ($scope$val = this.regexAccept(String.raw`(?:([^"\\]|\\.)*)`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:")`, $$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.Teacs_$0_2, start: $scope$start, val: $scope$val, end: $scope$end};
                }
                return $$res;
            });
    }
    public match_($$dpth: number, $$cr?: ErrorTracker): Nullable<_> {
        return this.loop<wspace>(() => this.matchwspace($$dpth + 1, $$cr), true);
    }
    public matchwspace($$dpth: number, $$cr?: ErrorTracker): Nullable<wspace> {
        return this.regexAccept(String.raw`(?:(?:\s|>--(?:(?!--<).)*(--<|\n|$)))`, $$dpth + 1, $$cr);
    }
    public matchgap($$dpth: number, $$cr?: ErrorTracker): Nullable<gap> {
        return this.choice<gap>([
            () => this.matchgap_1($$dpth + 1, $$cr),
            () => this.matchgap_2($$dpth + 1, $$cr),
            () => this.matchgap_3($$dpth + 1, $$cr),
        ]);
    }
    public matchgap_1($$dpth: number, $$cr?: ErrorTracker): Nullable<gap_1> {
        return this.matchwspace($$dpth + 1, $$cr);
    }
    public matchgap_2($$dpth: number, $$cr?: ErrorTracker): Nullable<gap_2> {
        return this.regexAccept(String.raw`(?:[^a-zA-Z0-9áéíóúÁÉÍÓÚ])`, $$dpth + 1, $$cr);
    }
    public matchgap_3($$dpth: number, $$cr?: ErrorTracker): Nullable<gap_3> {
        return this.regexAccept(String.raw`(?:$)`, $$dpth + 1, $$cr);
    }
    public matchPlusMinus($$dpth: number, $$cr?: ErrorTracker): Nullable<PlusMinus> {
        return this.regexAccept(String.raw`(?:\+|-)`, $$dpth + 1, $$cr);
    }
    public matchAsgnOp($$dpth: number, $$cr?: ErrorTracker): Nullable<AsgnOp> {
        return this.regexAccept(String.raw`(?:=|\+=|\*=|-=|%=|\/=|\/\/=)`, $$dpth + 1, $$cr);
    }
    public matchMulDiv($$dpth: number, $$cr?: ErrorTracker): Nullable<MulDiv> {
        return this.regexAccept(String.raw`(?:\*|\/\/|%|\/)`, $$dpth + 1, $$cr);
    }
    public matchCompare($$dpth: number, $$cr?: ErrorTracker): Nullable<Compare> {
        return this.regexAccept(String.raw`(?:<=|>=|<|>)`, $$dpth + 1, $$cr);
    }
    public matchKeyword($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword> {
        return this.choice<Keyword>([
            () => this.matchKeyword_1($$dpth + 1, $$cr),
            () => this.matchKeyword_2($$dpth + 1, $$cr),
            () => this.matchKeyword_3($$dpth + 1, $$cr),
            () => this.matchKeyword_4($$dpth + 1, $$cr),
            () => this.matchKeyword_5($$dpth + 1, $$cr),
            () => this.matchKeyword_6($$dpth + 1, $$cr),
            () => this.matchKeyword_7($$dpth + 1, $$cr),
            () => this.matchKeyword_8($$dpth + 1, $$cr),
            () => this.matchKeyword_9($$dpth + 1, $$cr),
        ]);
    }
    public matchKeyword_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword_1> {
        return this.regexAccept(String.raw`(?:m[áa])`, $$dpth + 1, $$cr);
    }
    public matchKeyword_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword_2> {
        return this.regexAccept(String.raw`(?:n[oó])`, $$dpth + 1, $$cr);
    }
    public matchKeyword_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword_3> {
        return this.regexAccept(String.raw`(?:nuair-a)`, $$dpth + 1, $$cr);
    }
    public matchKeyword_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword_4> {
        return this.regexAccept(String.raw`(?:f[ií]or|br[eé]ag)`, $$dpth + 1, $$cr);
    }
    public matchKeyword_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword_5> {
        return this.regexAccept(String.raw`(?:gn[ií]omh)`, $$dpth + 1, $$cr);
    }
    public matchKeyword_6($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword_6> {
        return this.regexAccept(String.raw`(?:chun-cinn)`, $$dpth + 1, $$cr);
    }
    public matchKeyword_7($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword_7> {
        return this.regexAccept(String.raw`(?:neamhn[ií])`, $$dpth + 1, $$cr);
    }
    public matchKeyword_8($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword_8> {
        return this.regexAccept(String.raw`(?:toradh)`, $$dpth + 1, $$cr);
    }
    public matchKeyword_9($$dpth: number, $$cr?: ErrorTracker): Nullable<Keyword_9> {
        return this.regexAccept(String.raw`(?:creatlach)`, $$dpth + 1, $$cr);
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchProgram(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchProgram(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchProgram(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const preMrk = this.mark();
            const t = func();
            if (t === null || this.pos.overallPos === preMrk.overallPos) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<Program>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}